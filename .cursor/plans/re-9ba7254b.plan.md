<!-- 9ba7254b-67cb-4834-833b-2d3476b8252e e417df61-18f7-467f-a200-03370d51bc9e -->
# Choosing ReAct vs Deterministic in LangGraph (and When to Combine)

### TL;DR

- **Use ReAct** for open-ended, exploratory, tool-choosing work (triage, research, retrieval, synthesis) with bounded guardrails.
- **Use deterministic** for known, auditable procedures (config changes, compliance checks, migrations) where repeatability and safety matter.
- **Hybrid is common in production**: a deterministic orchestrator invokes a ReAct subgraph for ambiguity; ReAct delegates irreversible actions to deterministic subflows.

### When to build a ReAct graph

- **High ambiguity, dynamic tool choice**: multi-hop retrieval, troubleshooting, explorations.
- **Uncertain step count/ordering**: dialog-based planning and adaptive branching.
- **Human-in-the-loop** workflows requiring iterative clarification.
- **Pros**: simple to extend; resilient to unknowns; faster to prototype.
- **Cons**: variable latency/cost; lower reproducibility; requires safety rails.
- **Guardrails to add**: step caps, timeouts, tool whitelists, structured outputs (JSON schema/grammar), critic/validator checks, observation size limits, budget gates, memory scoping.

### When to build a deterministic graph

- **Well-defined procedures**: change management, policy rollout, report generation, batch workflows.
- **Strong SLAs/compliance**: reproducibility, auditability, predictable cost/latency.
- **Irreversible side-effects**: device config writes, data mutations.
- **LLM usage pattern**: bounded steps for classification/extraction with JSON schemas; not to steer control flow dynamically.

### Hybrid patterns that work well (common in LangGraph)

- **Deterministic orchestrator → ReAct subgraph (research mode)**
  - Orchestrator owns stages, budgets, approvals; calls ReAct for triage/investigation.
- **ReAct front-end → deterministic subflows for side-effects**
  - Agent explores and proposes; irreversible actions run via audited, typed subflows.
- **Plan-and-execute**
  - Deterministic planner produces a structured plan; ReAct executes each step within quotas.
- **Gate-and-approve**
  - ReAct proposes change → deterministic validators (policy/safety) → optional interrupt for human approval.
- **Fallback/backstop**
  - On low confidence or policy violation, route to a conservative deterministic baseline.

### LangGraph features to leverage in both

- **Subgraphs**: compose ReAct inside deterministic or vice versa (`docs/langgraph/13-subgraphs.md`).
- **Interrupts / human approval**: `docs/langgraph/10-interupts.md`.
- **Checkpointing, time-travel, durability**: `docs/langgraph/07-persistence.md`, `docs/langgraph/11-time-travel.md`, `docs/langgraph/08-durable-execution.md`.
- **Observability & budgets**: `docs/langgraph/19-observability.md`.
- **Functional API** for deterministic nodes: `docs/langgraph/22-functional-api.md`.

### Concrete guidance for your repo

- You already have `src/autonomous_graph.py` (ReAct) and `src/deterministic_graph.py`.
- **Recommended default**: Make the deterministic graph the top-level orchestrator; embed the autonomous graph as a subgraph for “triage/investigate/summarize” tasks.
- **Route irreversible actions** (e.g., PAN-OS config writes, policy updates) to deterministic subflows with pre/post validators and diffs.
- **Add guardrails** to the ReAct subgraph: step cap, tool whitelist, JSON-schema outputs, budget per request.
- **Use interrupts** for approvals on high-risk operations; store decisions via checkpointing for audit.

### Minimal integration sketch (conceptual)

```python
# Deterministic orchestrator node
from langgraph.graph import StateGraph

# Assume these exist in your codebase
# from src.autonomous_graph import compiled_graph as react_graph
# from src.deterministic_graph import deterministic_steps

workflow = StateGraph(state_type=dict)

# route function decides when to research vs execute

def route_task(state):
    if state.get("needs_research"):
        return "react_subgraph"
    return "deterministic_execute"

workflow.add_node("route", route_task)
workflow.add_node("react_subgraph", react_graph)  # subgraph call
workflow.add_node("deterministic_execute", deterministic_execute)

workflow.add_edge("route", "react_subgraph")
workflow.add_edge("route", "deterministic_execute")
# add further edges/guards/interrupts as needed
```

### Decision checklist

- **Ambiguity high?** Prefer ReAct (with caps) else deterministic.
- **Side-effects irreversible?** Deterministic with validators/approvals.
- **Reproducibility/audit primary?** Deterministic.
- **Latency/cost predictability required?** Deterministic or bounded ReAct.
- **Need dialog/clarification?** ReAct with interrupts.
- **Safety/compliance constraints?** Deterministic control points around any ReAct.

### How they integrate in PAN-OS scenarios

- **Triage an incident / understand config drift**: ReAct subgraph (tool-using research) → produce a structured proposal.
- **Apply a policy change / commit config**: Deterministic subflow with diff preview, validators, approval interrupt, and commit/rollback.
- **Generate recommendations**: ReAct to synthesize; deterministic to verify against policy/XPath mappings before output.

### Testing & evaluation

- Use your existing datasets (`examples/dataset_template.json`) and scripts (`scripts/evaluate.py`).
- Track: correctness, reproducibility (re-run variance), latency/cost, tool call counts, approval rates, rollback incidents.
- Add golden tests for deterministic nodes; create scenario replays for ReAct runs with checkpointing.

### To-dos

- [ ] Choose default orchestrator (deterministic vs autonomous) and document rationale
- [ ] Embed autonomous graph as subgraph with routing in deterministic graph
- [ ] Add step caps, tool whitelist, JSON-schema outputs, budgets to ReAct
- [ ] Insert interrupts and validators for irreversible actions
- [ ] Define and run evaluation comparing flows (accuracy, cost, latency, variance)